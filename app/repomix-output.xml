This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
labubu-game/
  game.css
  page.tsx
  sounds.ts
  types.ts
globals.css
layout.tsx
page.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="labubu-game/game.css">
@import url('https://fonts.googleapis.com/css2?family=Bubblegum+Sans&display=swap');

.game-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  font-family: 'Bubblegum Sans', cursive;
}

.game-canvas {
  width: 100%;
  height: 100%;
  touch-action: none;
  cursor: pointer;
}

.menu-overlay,
.pause-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
  backdrop-filter: blur(10px);
}

.menu-content,
.pause-content {
  background: linear-gradient(135deg, #FFE5F1 0%, #FFF0F5 100%);
  padding: 3rem;
  border-radius: 30px;
  text-align: center;
  max-width: 90%;
  width: 400px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  animation: bounce-in 0.5s ease;
}

@keyframes bounce-in {
  0% {
    transform: scale(0.3);
    opacity: 0;
  }
  50% {
    transform: scale(1.05);
  }
  70% {
    transform: scale(0.95);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.game-title {
  font-size: 2.5rem;
  background: linear-gradient(45deg, #FF69B4, #FFD700, #00CED1);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 1.5rem;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  animation: rainbow 3s ease-in-out infinite;
}

@keyframes rainbow {
  0%, 100% {
    filter: hue-rotate(0deg);
  }
  50% {
    filter: hue-rotate(180deg);
  }
}

.game-description {
  margin-bottom: 2rem;
  color: #4A5568;
  font-size: 1.1rem;
  line-height: 1.8;
}

.game-description p {
  margin: 0.5rem 0;
}

.game-over-stats {
  background: rgba(255, 255, 255, 0.5);
  padding: 1rem;
  border-radius: 15px;
  margin-bottom: 1.5rem;
}

.final-score {
  font-size: 1.8rem;
  color: #FF1493;
  margin: 0.5rem 0;
  font-weight: bold;
}

.high-score {
  font-size: 1.4rem;
  color: #FFD700;
  margin: 0.5rem 0;
  font-weight: bold;
}

.play-button {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 1rem 3rem;
  font-size: 1.5rem;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
  font-family: 'Bubblegum Sans', cursive;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.play-button:hover {
  transform: translateY(-3px);
  box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
  background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
}

.play-button:active {
  transform: translateY(-1px);
}

.pause-content h2 {
  font-size: 2.5rem;
  color: #FF69B4;
  margin-bottom: 1rem;
}

.pause-content p {
  font-size: 1.3rem;
  color: #4A5568;
}

@media (max-width: 768px) {
  .menu-content,
  .pause-content {
    padding: 2rem;
    width: 95%;
  }
  
  .game-title {
    font-size: 2rem;
  }
  
  .game-description {
    font-size: 1rem;
  }
  
  .play-button {
    padding: 0.8rem 2rem;
    font-size: 1.2rem;
  }
}

.mute-button {
  position: fixed;
  top: 20px;
  left: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  border: 3px solid #FF69B4;
  font-size: 1.5rem;
  cursor: pointer;
  z-index: 100;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.mute-button:hover {
  transform: scale(1.1);
  background: #FFE5F1;
}

.mute-button:active {
  transform: scale(0.95);
}
</file>

<file path="labubu-game/page.tsx">
'use client';

import React, { useEffect, useRef, useState } from 'react';
import './game.css';
import { GameSounds } from './sounds';
import type { GameState, Labubu, Rainbow, Heart, Unicorn } from './types';

export default function LabubuGame() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  const [lives, setLives] = useState(3);
  const [isPaused, setIsPaused] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const animationRef = useRef<number | undefined>(undefined);
  const soundsRef = useRef<GameSounds | undefined>(undefined);
  
  const gameStateRef = useRef<GameState>({
    unicorn: { 
      x: 0, 
      y: 0, 
      width: 90, 
      height: 90,
      targetX: 0,
      bounce: 0,
      wingFlap: 0,
      catchAnimation: 0,
      magnetPull: false,
      magnetTimer: 0
    },
    labubus: [],
    rainbows: [],
    hearts: [],
    particles: [],
    stars: [],
    touchX: null,
    moveDirection: 0,
    combo: 0,
    powerUpActive: false,
    powerUpTimer: 0,
    frameCount: 0,
  });

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('labubuHighScore');
      if (saved) setHighScore(parseInt(saved));
      soundsRef.current = new GameSounds();
    }
  }, []);

  useEffect(() => {
    if (!canvasRef.current || !gameStarted || isPaused) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const gameState = gameStateRef.current;
    gameState.unicorn.x = canvas.width / 2 - 45;
    gameState.unicorn.y = canvas.height - 140;
    gameState.unicorn.targetX = canvas.width / 2 - 45;

    let lastSpawn = 0;
    let rainbowSpawn = 0;
    let heartSpawn = 0;

    const gameLoop = (timestamp: number) => {
      if (!ctx || !canvas) return;
      
      // Clear canvas
      ctx.fillStyle = '#FFE5F1';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw clouds
      drawClouds(ctx, canvas);
      
      // Update frame count for animations
      gameState.frameCount++;
      gameState.unicorn.wingFlap = Math.sin(gameState.frameCount * 0.15) * 5;
      gameState.unicorn.bounce = Math.sin(gameState.frameCount * 0.1) * 3;
      
      // Update unicorn position with magnet effect
      if (gameState.unicorn.magnetPull && gameState.unicorn.magnetTimer > 0) {
        gameState.unicorn.magnetTimer--;
        const centerX = canvas.width / 2 - gameState.unicorn.width / 2;
        gameState.unicorn.targetX += (centerX - gameState.unicorn.targetX) * 0.08;
        
        if (gameState.unicorn.magnetTimer <= 0) {
          gameState.unicorn.magnetPull = false;
        }
      } else if (gameState.touchX !== null) {
        gameState.unicorn.targetX = gameState.touchX - gameState.unicorn.width / 2;
      } else if (gameState.moveDirection !== 0) {
        gameState.unicorn.targetX += gameState.moveDirection * 10;
      }
      
      // Smooth movement with increased responsiveness for mobile
      gameState.unicorn.targetX = Math.max(0, Math.min(canvas.width - gameState.unicorn.width, gameState.unicorn.targetX));
      gameState.unicorn.x += (gameState.unicorn.targetX - gameState.unicorn.x) * 0.25;
      
      // Update catch animation
      if (gameState.unicorn.catchAnimation > 0) {
        gameState.unicorn.catchAnimation--;
      }
      
      // Spawn Labubus
      if (timestamp - lastSpawn > (1500 - Math.min(score * 5, 1000))) {
        gameState.labubus.push({
          x: Math.random() * (canvas.width - 60),
          y: -60,
          width: 60,
          height: 60,
          speed: 2 + Math.min(score / 50, 3),
          type: Math.random() > 0.9 ? 'golden' : 'normal',
          rotation: 0,
          wobble: Math.random() * Math.PI * 2,
          scale: 1,
        });
        lastSpawn = timestamp;
      }
      
      // Spawn Rainbows (power-ups)
      if (timestamp - rainbowSpawn > 15000) {
        gameState.rainbows.push({
          x: Math.random() * (canvas.width - 80),
          y: -80,
          width: 80,
          height: 40,
          speed: 3,
        });
        rainbowSpawn = timestamp;
      }
      
      // Spawn Hearts (extra lives)
      if (timestamp - heartSpawn > 30000 && lives < 3) {
        gameState.hearts.push({
          x: Math.random() * (canvas.width - 40),
          y: -40,
          width: 40,
          height: 40,
          speed: 2,
        });
        heartSpawn = timestamp;
      }
      
      // Update and draw Labubus
      gameState.labubus = gameState.labubus.filter(labubu => {
        labubu.y += labubu.speed;
        labubu.rotation += 0.05;
        labubu.wobble += 0.1;
        labubu.x += Math.sin(labubu.wobble) * 1.5;
        
        // Check collision with unicorn
        if (checkCollision(gameState.unicorn, labubu)) {
          const points = labubu.type === 'golden' ? 50 : 10;
          setScore(prev => {
            const newScore = prev + points * (gameState.powerUpActive ? 2 : 1);
            if (newScore > highScore) {
              setHighScore(newScore);
              localStorage.setItem('labubuHighScore', newScore.toString());
            }
            return newScore;
          });
          
          soundsRef.current?.playCollectSound(labubu.type === 'golden');
          gameState.combo++;
          
          // Trigger catch animation and magnet pull
          gameState.unicorn.catchAnimation = 20;
          gameState.unicorn.magnetPull = true;
          gameState.unicorn.magnetTimer = 15;
          
          // Create sparkle particles
          for (let i = 0; i < 15; i++) {
            gameState.particles.push({
              x: labubu.x + labubu.width / 2,
              y: labubu.y + labubu.height / 2,
              vx: (Math.random() - 0.5) * 10,
              vy: (Math.random() - 0.5) * 10,
              life: 40,
              size: Math.random() * 4 + 2,
              color: labubu.type === 'golden' ? '#FFD700' : '#FF69B4',
              type: Math.random() > 0.5 ? 'star' : 'circle',
            });
          }
          
          return false;
        }
        
        // Check if missed
        if (labubu.y > canvas.height) {
          gameState.combo = 0;
          soundsRef.current?.playMissSound();
          setLives(prev => {
            const newLives = prev - 1;
            if (newLives <= 0) {
              soundsRef.current?.playGameOverSound();
              endGame();
            }
            return newLives;
          });
          return false;
        }
        
        drawLabubu(ctx, labubu);
        return true;
      });
      
      // Update and draw Rainbows
      gameState.rainbows = gameState.rainbows.filter(rainbow => {
        rainbow.y += rainbow.speed;
        
        if (checkCollision(gameState.unicorn, rainbow)) {
          soundsRef.current?.playPowerUpSound();
          gameState.powerUpActive = true;
          gameState.powerUpTimer = 300; // 5 seconds at 60fps
          return false;
        }
        
        if (rainbow.y > canvas.height) return false;
        
        drawRainbow(ctx, rainbow);
        return true;
      });
      
      // Update and draw Hearts
      gameState.hearts = gameState.hearts.filter(heart => {
        heart.y += heart.speed;
        
        if (checkCollision(gameState.unicorn, heart)) {
          soundsRef.current?.playHeartSound();
          setLives(prev => Math.min(prev + 1, 5));
          return false;
        }
        
        if (heart.y > canvas.height) return false;
        
        drawHeart(ctx, heart);
        return true;
      });
      
      // Update particles
      gameState.particles = gameState.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.3;
        particle.life--;
        
        if (particle.life > 0) {
          ctx.globalAlpha = particle.life / 40;
          ctx.fillStyle = particle.color;
          
          if (particle.type === 'star') {
            ctx.save();
            ctx.translate(particle.x, particle.y);
            ctx.rotate(particle.life * 0.1);
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
              const r = i % 2 === 0 ? particle.size : particle.size * 0.5;
              ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          } else {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.globalAlpha = 1;
          return true;
        }
        return false;
      });
      
      // Update power-up timer
      if (gameState.powerUpActive) {
        gameState.powerUpTimer--;
        if (gameState.powerUpTimer <= 0) {
          gameState.powerUpActive = false;
        }
      }
      
      // Draw unicorn with rainbow trail if powered up
      if (gameState.powerUpActive) {
        drawRainbowTrail(ctx, gameState.unicorn);
      }
      drawUnicorn(ctx, gameState.unicorn);
      
      // Draw UI
      drawUI(ctx, canvas);
      
      animationRef.current = requestAnimationFrame(gameLoop);
    };
    
    const drawClouds = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(100, 100, 40, 0, Math.PI * 2);
      ctx.arc(140, 100, 50, 0, Math.PI * 2);
      ctx.arc(180, 100, 40, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(canvas.width - 150, 150, 35, 0, Math.PI * 2);
      ctx.arc(canvas.width - 110, 150, 45, 0, Math.PI * 2);
      ctx.arc(canvas.width - 70, 150, 35, 0, Math.PI * 2);
      ctx.fill();
    };
    
    const drawLabubu = (ctx: CanvasRenderingContext2D, labubu: Labubu) => {
      ctx.save();
      ctx.translate(labubu.x + labubu.width / 2, labubu.y + labubu.height / 2);
      ctx.rotate(labubu.rotation);
      
      const scale = labubu.scale || 1;
      ctx.scale(scale, scale);
      
      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(0, labubu.height / 2 - 5, labubu.width / 3, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Body with gradient
      const gradient = ctx.createRadialGradient(0, -5, 0, 0, 5, labubu.width / 2);
      if (labubu.type === 'golden') {
        gradient.addColorStop(0, '#FFEB3B');
        gradient.addColorStop(0.5, '#FFD700');
        gradient.addColorStop(1, '#FFA000');
      } else {
        gradient.addColorStop(0, '#D4A574');
        gradient.addColorStop(0.5, '#8B7355');
        gradient.addColorStop(1, '#6B5D54');
      }
      ctx.fillStyle = gradient;
      
      // Fluffy body shape
      ctx.beginPath();
      ctx.ellipse(0, 0, labubu.width / 2 - 2, labubu.height / 2 - 2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Fluffy texture
      ctx.strokeStyle = labubu.type === 'golden' ? '#FFE082' : '#A89585';
      ctx.lineWidth = 1;
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI * 2) / 8;
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * 18, Math.sin(angle) * 18, 8, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Ears with inner detail
      ctx.fillStyle = labubu.type === 'golden' ? '#FFD700' : '#8B7355';
      ctx.beginPath();
      ctx.ellipse(-18, -22, 14, 18, -0.3, 0, Math.PI * 2);
      ctx.ellipse(18, -22, 14, 18, 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner ears
      ctx.fillStyle = labubu.type === 'golden' ? '#FFE082' : '#D4A574';
      ctx.beginPath();
      ctx.ellipse(-16, -20, 8, 10, -0.3, 0, Math.PI * 2);
      ctx.ellipse(16, -20, 8, 10, 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Big cute eyes with sparkle
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(-12, -5, 5, 6, 0, 0, Math.PI * 2);
      ctx.ellipse(12, -5, 5, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye sparkles
      ctx.fillStyle = '#FFF';
      ctx.beginPath();
      ctx.arc(-10, -7, 2, 0, Math.PI * 2);
      ctx.arc(14, -7, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Cute nose
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(0, 2, 3, 2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Happy smile with teeth
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 6, 10, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.stroke();
      
      // Signature teeth
      ctx.fillStyle = '#FFF';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      // Left tooth
      ctx.fillRect(-6, 6, 4, 5);
      ctx.strokeRect(-6, 6, 4, 5);
      // Right tooth
      ctx.fillRect(2, 6, 4, 5);
      ctx.strokeRect(2, 6, 4, 5);
      
      // Blush marks
      ctx.fillStyle = 'rgba(255, 192, 203, 0.6)';
      ctx.beginPath();
      ctx.arc(-20, 2, 5, 0, Math.PI * 2);
      ctx.arc(20, 2, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Star decoration for golden
      if (labubu.type === 'golden') {
        ctx.fillStyle = '#FFF';
        ctx.save();
        ctx.translate(0, -35);
        ctx.rotate(gameStateRef.current.frameCount * 0.05);
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
          const r = i % 2 === 0 ? 8 : 4;
          ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      
      ctx.restore();
    };
    
    const drawUnicorn = (ctx: CanvasRenderingContext2D, unicorn: Unicorn) => {
      ctx.save();
      
      // Apply bounce animation
      const bounceY = unicorn.bounce || 0;
      const catchScale = unicorn.catchAnimation > 0 ? 1.1 - (unicorn.catchAnimation * 0.005) : 1;
      
      ctx.translate(unicorn.x + 45, unicorn.y + 45 + bounceY);
      ctx.scale(catchScale, catchScale);
      ctx.translate(-45, -45);
      
      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.beginPath();
      ctx.ellipse(45, 85, 35, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Wings (animated)
      const wingFlap = unicorn.wingFlap || 0;
      
      // Left wing
      ctx.save();
      ctx.translate(20, 40);
      ctx.rotate(-0.3 + Math.sin(wingFlap * 0.1) * 0.2);
      
      const wingGradientL = ctx.createLinearGradient(-20, 0, 0, 30);
      wingGradientL.addColorStop(0, 'rgba(255, 182, 193, 0.9)');
      wingGradientL.addColorStop(0.5, 'rgba(255, 192, 203, 0.7)');
      wingGradientL.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
      ctx.fillStyle = wingGradientL;
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-25, 10, -20, 30);
      ctx.quadraticCurveTo(-15, 35, -5, 35);
      ctx.quadraticCurveTo(-10, 20, 0, 0);
      ctx.fill();
      
      // Wing details
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-5, 10);
      ctx.quadraticCurveTo(-15, 15, -15, 25);
      ctx.stroke();
      
      ctx.restore();
      
      // Right wing
      ctx.save();
      ctx.translate(70, 40);
      ctx.rotate(0.3 - Math.sin(wingFlap * 0.1) * 0.2);
      
      const wingGradientR = ctx.createLinearGradient(20, 0, 0, 30);
      wingGradientR.addColorStop(0, 'rgba(255, 182, 193, 0.9)');
      wingGradientR.addColorStop(0.5, 'rgba(255, 192, 203, 0.7)');
      wingGradientR.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
      ctx.fillStyle = wingGradientR;
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(25, 10, 20, 30);
      ctx.quadraticCurveTo(15, 35, 5, 35);
      ctx.quadraticCurveTo(10, 20, 0, 0);
      ctx.fill();
      
      // Wing details
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.moveTo(5, 10);
      ctx.quadraticCurveTo(15, 15, 15, 25);
      ctx.stroke();
      
      ctx.restore();
      
      // Body with gradient
      const bodyGradient = ctx.createRadialGradient(45, 50, 10, 45, 50, 35);
      bodyGradient.addColorStop(0, '#FFFFFF');
      bodyGradient.addColorStop(0.7, '#FFF5F5');
      bodyGradient.addColorStop(1, '#FFE5F1');
      ctx.fillStyle = bodyGradient;
      
      ctx.beginPath();
      ctx.ellipse(45, 50, 35, 32, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Body highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.beginPath();
      ctx.ellipse(35, 40, 12, 15, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Legs with hooves
      const legPositions = [
        { x: 25, move: Math.sin(gameStateRef.current.frameCount * 0.1) * 2 },
        { x: 35, move: Math.sin(gameStateRef.current.frameCount * 0.1 + 1) * 2 },
        { x: 50, move: Math.sin(gameStateRef.current.frameCount * 0.1 + 2) * 2 },
        { x: 60, move: Math.sin(gameStateRef.current.frameCount * 0.1 + 3) * 2 }
      ];
      
      legPositions.forEach(leg => {
        // Leg
        ctx.fillStyle = '#FFF5F5';
        ctx.fillRect(leg.x, 70 + leg.move, 10, 18);
        
        // Hoof
        ctx.fillStyle = '#D4A574';
        ctx.beginPath();
        ctx.ellipse(leg.x + 5, 88 + leg.move, 6, 4, 0, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Neck
      ctx.fillStyle = bodyGradient;
      ctx.beginPath();
      ctx.ellipse(45, 30, 18, 25, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Head
      const headGradient = ctx.createRadialGradient(45, 20, 5, 45, 20, 25);
      headGradient.addColorStop(0, '#FFFFFF');
      headGradient.addColorStop(1, '#FFF5F5');
      ctx.fillStyle = headGradient;
      
      ctx.beginPath();
      ctx.ellipse(45, 20, 25, 22, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Muzzle
      ctx.fillStyle = '#FFE5F1';
      ctx.beginPath();
      ctx.ellipse(48, 25, 12, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Nostrils
      ctx.fillStyle = '#FFB6C1';
      ctx.beginPath();
      ctx.ellipse(45, 27, 2, 3, 0, 0, Math.PI * 2);
      ctx.ellipse(51, 27, 2, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Horn with spiral and sparkle
      const hornGradient = ctx.createLinearGradient(45, -5, 45, 15);
      hornGradient.addColorStop(0, '#FFE5B4');
      hornGradient.addColorStop(0.3, '#FFD700');
      hornGradient.addColorStop(0.6, '#FFA500');
      hornGradient.addColorStop(1, '#FFD700');
      
      ctx.fillStyle = hornGradient;
      ctx.beginPath();
      ctx.moveTo(45, -5);
      ctx.lineTo(40, 15);
      ctx.lineTo(50, 15);
      ctx.closePath();
      ctx.fill();
      
      // Horn spiral
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(43, 12);
      ctx.quadraticCurveTo(45, 5, 47, 0);
      ctx.quadraticCurveTo(45, -3, 45, -5);
      ctx.stroke();
      
      // Horn sparkle
      ctx.fillStyle = '#FFF';
      ctx.save();
      ctx.translate(45, -8);
      ctx.rotate(gameStateRef.current.frameCount * 0.05);
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * 6, Math.sin(angle) * 6);
      }
      ctx.stroke();
      ctx.restore();
      
      // Mane with flowing animation
      const maneColors = ['#FF69B4', '#FFB6C1', '#DDA0DD', '#BA55D3', '#9370DB'];
      const maneFlow = Math.sin(gameStateRef.current.frameCount * 0.05) * 2;
      
      for (let i = 0; i < 5; i++) {
        const gradient = ctx.createRadialGradient(
          25 + i * 4, 
          10 + i * 3 + maneFlow, 
          0,
          25 + i * 4, 
          10 + i * 3 + maneFlow, 
          15
        );
        gradient.addColorStop(0, maneColors[i]);
        gradient.addColorStop(1, maneColors[(i + 1) % maneColors.length]);
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.ellipse(
          25 + i * 4, 
          10 + i * 3 + maneFlow + Math.sin(gameStateRef.current.frameCount * 0.1 + i) * 2, 
          10 - i * 0.5, 
          15 - i, 
          0.3 + Math.sin(gameStateRef.current.frameCount * 0.05 + i) * 0.1, 
          0, 
          Math.PI * 2
        );
        ctx.fill();
      }
      
      // Tail
      for (let i = 0; i < 4; i++) {
        ctx.fillStyle = maneColors[i];
        ctx.beginPath();
        ctx.ellipse(
          15 + i * 3, 
          45 + i * 4 + Math.sin(gameStateRef.current.frameCount * 0.1 + i) * 3, 
          8, 
          20, 
          -0.5 + Math.sin(gameStateRef.current.frameCount * 0.05 + i) * 0.2, 
          0, 
          Math.PI * 2
        );
        ctx.fill();
      }
      
      // Eye with lashes
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(55, 18, 5, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye sparkle
      ctx.fillStyle = '#FFF';
      ctx.beginPath();
      ctx.arc(56, 16, 2, 0, Math.PI * 2);
      ctx.arc(54, 19, 1, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyelashes
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(58 + i * 2, 14 + i);
        ctx.lineTo(60 + i * 2, 12 + i);
        ctx.stroke();
      }
      
      // Blush
      ctx.fillStyle = 'rgba(255, 192, 203, 0.4)';
      ctx.beginPath();
      ctx.arc(65, 25, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    };
    
    const drawRainbow = (ctx: CanvasRenderingContext2D, rainbow: Rainbow) => {
      const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
      const stripeHeight = rainbow.height / colors.length;
      
      colors.forEach((color, i) => {
        ctx.fillStyle = color;
        ctx.fillRect(rainbow.x, rainbow.y + i * stripeHeight, rainbow.width, stripeHeight);
      });
    };
    
    const drawRainbowTrail = (ctx: CanvasRenderingContext2D, unicorn: Unicorn) => {
      const colors = ['#FF000030', '#FF7F0030', '#FFFF0030', '#00FF0030', '#0000FF30', '#4B008230', '#9400D330'];
      colors.forEach((color, i) => {
        ctx.fillStyle = color;
        ctx.fillRect(unicorn.x - i * 5, unicorn.y + 70 + i * 2, unicorn.width + i * 10, 5);
      });
    };
    
    const drawHeart = (ctx: CanvasRenderingContext2D, heart: Heart) => {
      ctx.fillStyle = '#FF1493';
      ctx.beginPath();
      ctx.moveTo(heart.x + 20, heart.y + 10);
      ctx.bezierCurveTo(heart.x + 20, heart.y, heart.x, heart.y, heart.x, heart.y + 15);
      ctx.bezierCurveTo(heart.x, heart.y + 25, heart.x + 20, heart.y + 35, heart.x + 20, heart.y + 40);
      ctx.bezierCurveTo(heart.x + 20, heart.y + 35, heart.x + 40, heart.y + 25, heart.x + 40, heart.y + 15);
      ctx.bezierCurveTo(heart.x + 40, heart.y, heart.x + 20, heart.y, heart.x + 20, heart.y + 10);
      ctx.fill();
    };
    
    const drawUI = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
      // Score
      ctx.fillStyle = '#FF69B4';
      ctx.font = 'bold 24px Comic Sans MS, cursive';
      ctx.fillText(`Score: ${score}`, 20, 40);
      
      // High Score
      ctx.fillStyle = '#FFD700';
      ctx.fillText(`Best: ${highScore}`, 20, 70);
      
      // Lives
      for (let i = 0; i < lives; i++) {
        drawHeart(ctx, { x: canvas.width - 60 - i * 50, y: 20, width: 40, height: 40, speed: 0 });
      }
      
      // Combo
      if (gameStateRef.current.combo > 1) {
        ctx.fillStyle = '#FF1493';
        ctx.font = 'bold 32px Comic Sans MS, cursive';
        ctx.fillText(`${gameStateRef.current.combo}x Combo!`, canvas.width / 2 - 80, 100);
      }
      
      // Power-up indicator
      if (gameStateRef.current.powerUpActive) {
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 28px Comic Sans MS, cursive';
        ctx.fillText('RAINBOW POWER!', canvas.width / 2 - 100, 150);
      }
    };
    
    const checkCollision = (rect1: { x: number; y: number; width: number; height: number }, rect2: { x: number; y: number; width: number; height: number }) => {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    };
    
    const endGame = () => {
      setGameStarted(false);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
    
    // Touch controls
    const handleTouch = (e: TouchEvent) => {
      e.preventDefault();
      if (e.touches.length > 0) {
        gameState.touchX = e.touches[0].clientX;
      }
    };
    
    const handleTouchEnd = () => {
      gameState.touchX = null;
    };
    
    // Keyboard controls
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'ArrowLeft') gameState.moveDirection = -1;
      if (e.key === 'ArrowRight') gameState.moveDirection = 1;
      if (e.key === ' ') {
        e.preventDefault();
        setIsPaused(prev => !prev);
      }
    };
    
    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        gameState.moveDirection = 0;
      }
    };
    
    canvas.addEventListener('touchstart', handleTouch, { passive: false });
    canvas.addEventListener('touchmove', handleTouch, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    animationRef.current = requestAnimationFrame(gameLoop);
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      canvas.removeEventListener('touchstart', handleTouch);
      canvas.removeEventListener('touchmove', handleTouch);
      canvas.removeEventListener('touchend', handleTouchEnd);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [gameStarted, isPaused, score, highScore, lives]);

  const startGame = () => {
    setScore(0);
    setLives(3);
    setGameStarted(true);
    setIsPaused(false);
    soundsRef.current?.init();
    soundsRef.current?.playBackgroundMusic();
    
    const canvas = canvasRef.current;
    const centerX = canvas ? canvas.width / 2 - 45 : window.innerWidth / 2 - 45;
    
    gameStateRef.current = {
      unicorn: { 
        x: centerX, 
        y: 0, 
        width: 90, 
        height: 90,
        targetX: centerX,
        bounce: 0,
        wingFlap: 0,
        catchAnimation: 0,
        magnetPull: false,
        magnetTimer: 0
      },
      labubus: [],
      rainbows: [],
      hearts: [],
      particles: [],
      stars: [],
      touchX: null,
      moveDirection: 0,
      combo: 0,
      powerUpActive: false,
      powerUpTimer: 0,
      frameCount: 0,
    };
  };
  
  const toggleMute = () => {
    const muted = soundsRef.current?.toggleMute();
    setIsMuted(muted || false);
  };

  return (
    <div className="game-container">
      {!gameStarted && (
        <div className="menu-overlay">
          <div className="menu-content">
            <h1 className="game-title">🦄 Labubu Rainbow Catch! 🌈</h1>
            <div className="game-description">
              <p>Help the unicorn catch falling Labubus!</p>
              <p>🎮 Touch or use arrow keys to move</p>
              <p>✨ Golden Labubus = 50 points!</p>
              <p>🌈 Rainbows = Double points!</p>
              <p>💖 Hearts = Extra lives!</p>
            </div>
            {score > 0 && (
              <div className="game-over-stats">
                <p className="final-score">Final Score: {score}</p>
                <p className="high-score">Best Score: {highScore}</p>
              </div>
            )}
            <button className="play-button" onClick={startGame}>
              {score > 0 ? 'Play Again! 🎮' : 'Start Game! 🎮'}
            </button>
          </div>
        </div>
      )}
      
      {gameStarted && (
        <button 
          className="mute-button" 
          onClick={toggleMute}
          aria-label={isMuted ? "Unmute" : "Mute"}
        >
          {isMuted ? '🔇' : '🔊'}
        </button>
      )}
      
      {isPaused && gameStarted && (
        <div className="pause-overlay">
          <div className="pause-content">
            <h2>Game Paused</h2>
            <p>Press SPACE or tap to continue</p>
          </div>
        </div>
      )}
      
      <canvas 
        ref={canvasRef}
        className="game-canvas"
        onClick={() => isPaused && setIsPaused(false)}
      />
    </div>
  );
}
</file>

<file path="labubu-game/sounds.ts">
export class GameSounds {
  private audioContext: AudioContext | null = null;
  private isMuted: boolean = false;
  
  constructor() {
    if (typeof window !== 'undefined') {
      const AudioContextClass = window.AudioContext || (window as typeof window & { webkitAudioContext?: typeof AudioContext }).webkitAudioContext;
      if (AudioContextClass) {
        this.audioContext = new AudioContextClass();
      }
    }
  }
  
  private createOscillator(frequency: number, duration: number, type: OscillatorType = 'sine') {
    if (!this.audioContext || this.isMuted) return;
    
    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    oscillator.frequency.value = frequency;
    oscillator.type = type;
    
    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + duration);
  }
  
  playCollectSound(isGolden: boolean = false) {
    if (isGolden) {
      this.createOscillator(523.25, 0.1); // C5
      setTimeout(() => this.createOscillator(659.25, 0.1), 50); // E5
      setTimeout(() => this.createOscillator(783.99, 0.15), 100); // G5
    } else {
      this.createOscillator(440, 0.1); // A4
      setTimeout(() => this.createOscillator(554.37, 0.1), 50); // C#5
    }
  }
  
  playPowerUpSound() {
    const notes = [261.63, 329.63, 392, 523.25]; // C4, E4, G4, C5
    notes.forEach((note, index) => {
      setTimeout(() => this.createOscillator(note, 0.2, 'square'), index * 100);
    });
  }
  
  playHeartSound() {
    this.createOscillator(440, 0.15, 'triangle'); // A4
    setTimeout(() => this.createOscillator(554.37, 0.15, 'triangle'), 100); // C#5
    setTimeout(() => this.createOscillator(659.25, 0.2, 'triangle'), 200); // E5
  }
  
  playMissSound() {
    this.createOscillator(130.81, 0.3, 'sawtooth'); // C3
  }
  
  playGameOverSound() {
    const notes = [392, 349.23, 329.63, 293.66]; // G4, F4, E4, D4
    notes.forEach((note, index) => {
      setTimeout(() => this.createOscillator(note, 0.3, 'square'), index * 200);
    });
  }
  
  playBackgroundMusic() {
    if (!this.audioContext || this.isMuted) return;
    
    const playNote = (frequency: number, startTime: number, duration: number) => {
      const oscillator = this.audioContext!.createOscillator();
      const gainNode = this.audioContext!.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext!.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = 'triangle';
      
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(0.1, startTime + 0.01);
      gainNode.gain.setValueAtTime(0.1, startTime + duration - 0.01);
      gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
      
      oscillator.start(startTime);
      oscillator.stop(startTime + duration);
    };
    
    const melody = [
      { note: 523.25, time: 0, duration: 0.25 },     // C5
      { note: 523.25, time: 0.25, duration: 0.25 },  // C5
      { note: 783.99, time: 0.5, duration: 0.25 },   // G5
      { note: 783.99, time: 0.75, duration: 0.25 },  // G5
      { note: 880, time: 1, duration: 0.25 },        // A5
      { note: 880, time: 1.25, duration: 0.25 },     // A5
      { note: 783.99, time: 1.5, duration: 0.5 },    // G5
      { note: 698.46, time: 2, duration: 0.25 },     // F5
      { note: 698.46, time: 2.25, duration: 0.25 },  // F5
      { note: 659.25, time: 2.5, duration: 0.25 },   // E5
      { note: 659.25, time: 2.75, duration: 0.25 },  // E5
      { note: 587.33, time: 3, duration: 0.25 },     // D5
      { note: 587.33, time: 3.25, duration: 0.25 },  // D5
      { note: 523.25, time: 3.5, duration: 0.5 },    // C5
    ];
    
    const startTime = this.audioContext.currentTime;
    const loopDuration = 4;
    
    const scheduleLoop = () => {
      melody.forEach(({ note, time, duration }) => {
        playNote(note, startTime + time, duration);
      });
      
      if (!this.isMuted) {
        setTimeout(() => scheduleLoop(), loopDuration * 1000);
      }
    };
    
    scheduleLoop();
  }
  
  toggleMute() {
    this.isMuted = !this.isMuted;
    return this.isMuted;
  }
  
  init() {
    if (this.audioContext?.state === 'suspended') {
      this.audioContext.resume();
    }
  }
}
</file>

<file path="labubu-game/types.ts">
export interface Unicorn {
  x: number;
  y: number;
  width: number;
  height: number;
  targetX: number;
  bounce: number;
  wingFlap: number;
  catchAnimation: number;
  magnetPull: boolean;
  magnetTimer: number;
}

export interface Labubu {
  x: number;
  y: number;
  width: number;
  height: number;
  speed: number;
  type: 'normal' | 'golden';
  rotation: number;
  wobble: number;
  scale: number;
}

export interface Rainbow {
  x: number;
  y: number;
  width: number;
  height: number;
  speed: number;
}

export interface Heart {
  x: number;
  y: number;
  width: number;
  height: number;
  speed: number;
}

export interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  size: number;
  color: string;
  type: 'star' | 'circle';
}

export interface GameState {
  unicorn: Unicorn;
  labubus: Labubu[];
  rainbows: Rainbow[];
  hearts: Heart[];
  particles: Particle[];
  stars: unknown[];
  touchX: number | null;
  moveDirection: number;
  combo: number;
  powerUpActive: boolean;
  powerUpTimer: number;
  frameCount: number;
}
</file>

<file path="globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="page.tsx">
import Link from "next/link";

export default function Home() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-purple-400 via-pink-300 to-blue-300">
      <div className="text-center p-8 bg-white/90 rounded-3xl shadow-2xl max-w-md">
        <h1 className="text-4xl font-bold mb-4 bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
          🦄 Labubu Rainbow Catch! 🌈
        </h1>
        <p className="text-gray-700 mb-8 text-lg">
          A cute and addictive game featuring Labubu, unicorns, and rainbows!
        </p>
        <Link
          href="/labubu-game"
          className="inline-block px-8 py-4 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold text-xl rounded-full hover:scale-105 transition-transform shadow-lg"
        >
          Play Now! 🎮
        </Link>
        <div className="mt-6 text-sm text-gray-600">
          <p>🎯 Catch the falling Labubus</p>
          <p>🌈 Collect rainbow power-ups</p>
          <p>💖 Perfect for mobile play</p>
        </div>
      </div>
    </div>
  );
}
</file>

</files>
